use std::ops::Rem;

use num_bigint::{BigInt, Sign};
use scrypt::ScryptParams;
use sha3::{
    digest::{core_api::CoreWrapper, ExtendableOutput, Update, XofReader},
    Digest, Sha3_512, Shake256, Shake256Core,
};

// Variables for scrypt hashing
const LOG_N: u8 = 15;
const R: u32 = 8;
const P: u32 = 1;

static ALLOWED_CHARACTERS: &str =
    "@#$%&*._!0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
static ALPHABETS: &str = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
static UPPERCASE_ALPHABETS: &str = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
static LOWERCASE_ALPHABETS: &str = "abcdefghijklmnopqrstuvwxyz";
static NUMBERS: &str = "1234567890";
static VALID_SYMBOLS: &str = "@#$%&*._!";

// Takes in string and returns an array of bytes
pub fn encode_utf8(input: String) -> Vec<u8> {
    input.as_bytes().to_owned()
}

// Generate a random number from 0 to modulo-1
fn generate_index(hasher: &mut CoreWrapper<Shake256Core>, hash_bytes: &[u8], modulo: i64) -> usize {
    // Feed hash_string as seed to SHAKE256
    hasher.update(hash_bytes);
    let mut reader = hasher.to_owned().finalize_xof();
    // prng is a 256 bit array generated by SHAKE256
    let mut prng = [0u8; 32];
    reader.read(&mut prng);

    // Convert the 256 bit array to 256 bit BigInt
    let (_s, v) = BigInt::from_bytes_be(Sign::Plus, &prng.to_vec())
        .rem(modulo)
        .to_u64_digits();
    let mut sum = 0;
    v.into_iter().for_each(|val| {
        sum *= 10;
        sum += val;
    });
    return sum.try_into().unwrap();
}

// Removes Numbers or Symbols from Pashword
pub fn sanitize(pashword: &str, no_symbols: bool, no_numbers: bool) -> String {
    // Initialize SHAKE256 for PRNG
    let mut hasher = Shake256::default();
    let mut password_array: Vec<char> = pashword.chars().collect();

    // If symbols have to be removed
    if no_symbols {
        for i in 0..password_array.len() {
            // If character is a symbol
            if VALID_SYMBOLS.contains(password_array[i]) {
                // Generate a random index using the (index+number)
                // Replace the symbol with an alphabet at the generated index
                password_array[i] = ALPHABETS
                    .chars()
                    .nth(generate_index(
                        &mut hasher,
                        (i.to_string() + &password_array[i].to_string()).as_bytes(),
                        ALPHABETS.chars().count().try_into().unwrap(),
                    ))
                    .unwrap();
            }
        }
    }

    // If numbers have to be removed
    if no_numbers {
        for i in 0..password_array.len() {
            // If character is a number
            if NUMBERS.contains(password_array[i]) {
                // Generate a random index using the (index+number)
                // Replace the number with an alphabet at the generated index
                password_array[i] = ALPHABETS
                    .chars()
                    .nth(generate_index(
                        &mut hasher,
                        (i.to_string() + &password_array[i].to_string()).as_bytes(),
                        ALPHABETS.chars().count().try_into().unwrap(),
                    ))
                    .unwrap();
            }
        }
    }

    // Return the pashword array as string
    password_array.iter().collect()
}

// Generate a random index from 0 to character_set.len()
// and return the character at that index
fn pick_character(
    hasher: &mut CoreWrapper<Shake256Core>,
    scrypt_hash_raw: &[u8],
    character_set: &str,
) -> char {
    character_set
        .chars()
        .nth(generate_index(
            hasher,
            scrypt_hash_raw,
            character_set.chars().count().try_into().unwrap(),
        ))
        .unwrap()
}

pub fn generate_pashword(
    to_hash: &str,
    pashword_length: i32,
    website: &str,
    username: &str,
) -> String {
    // INITIALIZE SHAKE256 FOR PRNG
    let mut shake_hasher = Shake256::default();
    // INITIALIZE SHA3-512 FOR FIRST ENCRYPTION
    let mut sha512_hasher = Sha3_512::new();

    // Convert toHash json object to its own SHA3-512 hash sum in HEX
    Digest::update(&mut sha512_hasher, to_hash.as_bytes());
    let hash_pass = hex::encode(&sha512_hasher.finalize()[..]);

    // Generate Scrypt Hash
    let params = ScryptParams::new(LOG_N, R, P).unwrap();
    let mut scrypt_hash_raw: Vec<u8> = vec![0; 32];
    let _res = scrypt::scrypt(
        hash_pass.as_bytes(),
        &encode_utf8(website.to_owned() + &username.to_owned()),
        &params,
        &mut scrypt_hash_raw,
    );

    // Generate Array: 0,1,2,3,4,5,6...pashword_length-1
    let mut pick_index: Vec<u32> = Vec::new();
    for i in 0..pashword_length {
        pick_index.insert(i.try_into().unwrap(), i.try_into().unwrap());
    }

    // generate a random index from 0 to pick_index.len()
    let mut remove_index = generate_index(
        &mut shake_hasher,
        &scrypt_hash_raw.to_owned(),
        pick_index.len().try_into().unwrap(),
    );
    // index1 is the element at that generated index
    // and the value is between 0 and pashword_length-1
    let index1 = pick_index[remove_index];
    // remove that element from the pick_index array
    // we can never pick the same element from pick_index again
    // and pick_index.len() decrements by one
    pick_index.remove(remove_index);

    // Repeat 3 more times for index2, index3 and index4
    remove_index = generate_index(
        &mut shake_hasher,
        &scrypt_hash_raw,
        pick_index.len().try_into().unwrap(),
    );
    let index2 = pick_index[remove_index];
    pick_index.remove(remove_index);

    remove_index = generate_index(
        &mut shake_hasher,
        &scrypt_hash_raw,
        pick_index.len().try_into().unwrap(),
    );
    let index3 = pick_index[remove_index];
    pick_index.remove(remove_index);

    remove_index = generate_index(
        &mut shake_hasher,
        &scrypt_hash_raw,
        pick_index.len().try_into().unwrap(),
    );
    let index4 = pick_index[remove_index];
    pick_index.remove(remove_index);

    let mut pashword: String = String::new();
    // Build a pashword from 0 to pashword_length-1
    for i in 0u32..pashword_length.try_into().unwrap() {
        if i == index1 {
            // pick character from lowercase if index1
            pashword.insert(
                i.try_into().unwrap(),
                pick_character(&mut shake_hasher, &scrypt_hash_raw, LOWERCASE_ALPHABETS),
            );
        } else if i == index2 {
            // pick character from uppercase if index2
            pashword.insert(
                i.try_into().unwrap(),
                pick_character(&mut shake_hasher, &scrypt_hash_raw, UPPERCASE_ALPHABETS),
            );
        } else if i == index3 {
            // pick character from symbols if index3
            pashword.insert(
                i.try_into().unwrap(),
                pick_character(&mut shake_hasher, &scrypt_hash_raw, VALID_SYMBOLS),
            );
        } else if i == index4 {
            // pick character from numbers if index4
            pashword.insert(
                i.try_into().unwrap(),
                pick_character(&mut shake_hasher, &scrypt_hash_raw, NUMBERS),
            );
        } else {
            // pick a character from universal set for other indices
            pashword.insert(
                i.try_into().unwrap(),
                pick_character(&mut shake_hasher, &scrypt_hash_raw, ALLOWED_CHARACTERS),
            );
        }
    }
    return pashword;
}
